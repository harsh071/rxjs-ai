---
title: rxjs-ai
description: A stream-first AI SDK built on RxJS.
template: splash
hero:
  tagline: The AI SDK for developers who think in streams. Observable-native, composable, zero framework lock-in.
  actions:
    - text: Get Started
      link: /getting-started/introduction/
      icon: right-arrow
    - text: Playground
      link: https://rxjs-ai-playground.vercel.app/
      icon: external
      variant: minimal
    - text: View on GitHub
      link: https://github.com/harsh071/rxjs-ai
      icon: external
      variant: minimal
---

import { Card, CardGrid } from '@astrojs/starlight/components';

## Why rxjs-ai?

<CardGrid stagger>
  <Card title="Stream-First" icon="rocket">
    Every AI call returns an Observable. Compose with `retry`, `timeout`, `takeUntil`, `switchMap`, `debounceTime`, `merge`, `race` and 100+ more RxJS operators.
  </Card>
  <Card title="Cancel in One Call" icon="close">
    `unsubscribe()` cancels everything. No AbortController ceremony, no cleanup callbacks. RxJS handles it.
  </Card>
  <Card title="Framework Agnostic" icon="puzzle">
    Core works everywhere: Node.js, browser, any framework. Optional hooks for React, Vue, Svelte, and Angular.
  </Card>
  <Card title="Ergonomic Primitives" icon="document">
    `createStore` and `createCommandBus` are thin layers on top of RxJS â€” the reactive patterns you'd write yourself, without the boilerplate.
  </Card>
</CardGrid>

## Quick Example

```ts
import { createChatController } from "rxjs-ai";
import { Observable } from "rxjs";

const model = {
  complete: ({ messages, signal }) =>
    new Observable((subscriber) => {
      const last = messages[messages.length - 1];
      subscriber.next(`Echo: ${last?.content ?? ""}`);
      subscriber.complete();
    }),
};

const chat = createChatController(model);

chat.status$.subscribe((status) => console.log("Status:", status));
chat.messages$.subscribe((msgs) => console.log("Messages:", msgs.length));

chat.send("Hello, AI!");
```

## Install

```bash
npm install rxjs-ai rxjs
```
