---
title: React
description: React hooks for bridging RxJS Observables to component state.
---

## Installation

The React bindings ship as part of the main `rxjs-ai` package — no extra dependency needed.

```ts
import { useObservableValue } from "rxjs-ai/react";
```

## useObservableValue

```ts
function useObservableValue<T>(source$: Observable<T>, initialValue: T): T;
```

Subscribe to an RxJS `Observable` and return its latest value as React component state. The hook manages the subscription lifecycle automatically — it subscribes on mount, updates state on each emission, and unsubscribes on unmount.

### Parameters

| Parameter | Type | Description |
|---|---|---|
| `source$` | `Observable<T>` | The Observable to subscribe to. |
| `initialValue` | `T` | The value returned before the first emission. |

### Returns

The most recently emitted value from `source$`, or `initialValue` if nothing has been emitted yet.

## Full chat component example

```tsx
import { useMemo } from "react";
import { createChatController } from "rxjs-ai";
import { useObservableValue } from "rxjs-ai/react";

// Assume `adapter` is a ChatModelAdapter you have defined elsewhere
import { adapter } from "./my-adapter";

function Chat() {
  // Create the controller once and memoize it
  const chat = useMemo(() => createChatController({ adapter }), []);

  // Bridge Observables into React state
  const messages = useObservableValue(chat.messages$, []);
  const status = useObservableValue(chat.status$, "idle");
  const error = useObservableValue(chat.error$, null);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const form = e.currentTarget;
    const input = new FormData(form).get("message") as string;
    if (!input.trim()) return;
    chat.send(input.trim());
    form.reset();
  };

  return (
    <div>
      <ul>
        {messages.map((msg) => (
          <li key={msg.id}>
            <strong>{msg.role}:</strong> {msg.content}
          </li>
        ))}
      </ul>

      {status === "streaming" && <p>AI is typing...</p>}
      {error && <p style={{ color: "red" }}>{error.message}</p>}

      <form onSubmit={handleSubmit}>
        <input name="message" placeholder="Type a message..." />
        <button type="submit" disabled={status === "loading" || status === "streaming"}>
          Send
        </button>
      </form>

      {status === "streaming" && (
        <button onClick={() => chat.cancel()}>Cancel</button>
      )}
      {status === "error" && (
        <button onClick={() => chat.retryLast()}>Retry</button>
      )}
    </div>
  );
}
```

## How it works

Under the hood, `useObservableValue` is a thin wrapper around `useState` and `useEffect`:

```ts
function useObservableValue<T>(source$: Observable<T>, initialValue: T): T {
  const [value, setValue] = useState<T>(initialValue);

  useEffect(() => {
    const sub = source$.subscribe((next) => setValue(next));
    return () => sub.unsubscribe();
  }, [source$]);

  return value;
}
```

1. **`useState`** holds the latest emitted value.
2. **`useEffect`** subscribes when the component mounts (or when `source$` changes) and unsubscribes on cleanup.
3. Each emission triggers a React re-render with the new value.

## Tips

### Avoid creating new Observables in render

Every time a component renders, any inline expression produces a **new** object reference. If you write `useObservableValue(chat.messages$.pipe(map(...)), [])` directly in the render body, the `useEffect` dependency will change on every render, causing an infinite subscribe/unsubscribe loop.

Instead, **memoize** derived Observables:

```tsx
import { useMemo } from "react";
import { map } from "rxjs";

function MessageCount({ chat }: { chat: ChatController }) {
  // Stable reference — only recomputed when `chat` changes
  const count$ = useMemo(
    () => chat.messages$.pipe(map((msgs) => msgs.length)),
    [chat],
  );

  const count = useObservableValue(count$, 0);
  return <span>{count} messages</span>;
}
```

### Memoize selectors

If multiple components need different slices of the same state, create the derived Observables once and share them:

```ts
function useChatSelectors(chat: ChatController) {
  return useMemo(
    () => ({
      userMessages$: chat.messages$.pipe(
        map((msgs) => msgs.filter((m) => m.role === "user")),
      ),
      lastAssistant$: chat.messages$.pipe(
        map((msgs) => msgs.filter((m) => m.role === "assistant").at(-1)),
      ),
      isLoading$: chat.status$.pipe(map((s) => s === "loading" || s === "streaming")),
    }),
    [chat],
  );
}
```

This ensures each selector Observable is created once per controller instance, keeping subscriptions efficient and avoiding unnecessary re-renders.
